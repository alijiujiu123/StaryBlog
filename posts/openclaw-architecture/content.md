# OpenClaw 技术架构深度研究

## 1. 整体架构设计

### 1.1 架构范式与核心理念

#### 1.1.1 Gateway-Centric 架构模式

OpenClaw 采用独特的 **Gateway-centric architecture（以网关为中心的架构）**，这一设计范式将整个系统的控制平面集中于单一长期运行的 Gateway 进程中。与传统的分布式微服务架构不同，OpenClaw 刻意选择了这种集中式设计，其核心动机在于确保系统的 **可靠性、安全性与简洁性**。Gateway 作为单一控制源（single source），承担了消息路由、会话管理、信道连接、智能体协调等多重职责，这种设计显著降低了系统复杂度，避免了分布式系统中常见的状态一致性问题。

该架构模式的技术实现体现在 Gateway 进程的多功能集成上：它同时作为 **WebSocket 服务器**（默认端口 18789）、**HTTP 文件服务器**（Canvas 主机，端口 18793）、信道适配器管理器以及智能体通信协调器运行。这种"一进程多角色"的设计看似与云原生时代的解耦趋势相悖，实则是针对个人 AI 助手场景的深度优化——个人用户无需面对企业级系统的运维复杂性，单个进程即可提供完整功能栈。

Gateway-centric 架构的另一关键优势在于 **状态管理的集中化**。所有会话状态、认证令牌、智能体配置均维护在 Gateway 进程内部，避免了外部依赖（如 Redis、数据库）带来的部署负担。这种设计使得 OpenClaw 能够在纯本地环境中运行，无需网络连接即可提供核心功能，完美契合其"本地优先"的产品定位。官方文档明确建议 **"One Gateway per host"** 的部署原则，即每个主机只运行一个 Gateway 实例，这一限制源于 WhatsApp Web 协议的会话独占性要求——Gateway 是唯一被允许拥有 WhatsApp Web 会话的进程，以此确保连接稳定性并防止会话冲突。

#### 1.1.2 本地优先（Local-First）设计哲学

OpenClaw 的本地优先设计哲学贯穿架构的各个层面，这不仅是技术选择，更是对产品价值观的坚守。在 **数据存储层面**，所有用户数据、会话历史、智能体记忆均默认存储于本地文件系统，具体位于 `~/.openclaw/` 目录下，而非云端服务。这种设计赋予用户完整的数据主权，消除了对第三方云服务的数据泄露担忧。

本地优先的实现需要解决一系列技术挑战。首先是 **模型推理的本地化支持**：OpenClaw 采用 **模型无关（model-agnostic）设计**，兼容 Claude、GPT、Gemini 等云端 API，同时支持通过 Ollama 等工具接入 Llama、Mixtral 等本地模型。其次是 **功能完整性保障**：即使完全离线，用户仍可通过本地模型与智能体交互，核心工具（文件操作、脚本执行）照常运行。最后是 **跨设备同步问题**：OpenClaw 通过可选的端到端加密同步机制，允许用户在多台设备间安全地迁移数据，而非依赖中心化云服务。

网络架构层面，本地优先体现为 **Loopback-First 网络策略**。Gateway 的 WebSocket 控制平面默认绑定 `ws://127.0.0.1:18789`，仅接受来自本机的连接。这种"默认拒绝远程访问"的设计大幅降低了攻击面。对于确有远程访问需求的场景，官方推荐通过 **SSH 隧道、Tailscale 等零信任网络方案** 实现，而非直接暴露服务端口。这一设计决策反映了 OpenClaw 团队对安全性的审慎态度——便利性不应以牺牲默认安全性为代价。

#### 1.1.3 去中心化与数据主权保障

OpenClaw 的去中心化特性体现在多个维度。最显著的是 **部署拓扑的去中心化**：每个用户运行独立的 Gateway 实例，不存在共享的中央服务器。这种架构从根本上消除了单点故障和大规模数据泄露的风险，与当前主流 AI 助手（如 ChatGPT、Claude）的集中式服务模式形成鲜明对比。

数据主权保障通过技术手段与架构设计的结合实现。**技术层面**，OpenClaw 采用纯本地存储，用户可通过文件系统直接访问、备份、修改所有数据。**架构层面**，工作区隔离机制确保不同智能体、不同会话的数据相互独立，用户可精确控制数据的可见范围。例如，`MEMORY.md` 文件仅在主会话（用户与 AI 的私密对话）中加载，在群聊或共享上下文中自动排除，防止个人信息意外泄露。

去中心化架构也带来了独特的挑战。缺乏中央协调意味着智能体间协作需要显式的点对点通信机制，OpenClaw 通过 Gateway 的中转服务实现这一点。版本更新和功能迭代依赖社区驱动的分发渠道（如 GitHub、ClawHub），而非强制推送。这些权衡反映了 OpenClaw 对 **"用户控制"优先于"运营效率"** 的价值排序。

### 1.2 核心组件体系

#### 1.2.1 Gateway（网关层）

##### 1.2.1.1 统一控制平面功能

Gateway 作为 OpenClaw 的心脏，其统一控制平面功能通过多层技术栈实现。最底层是高性能异步 I/O 基础设施，基于 **Node.js/TypeScript** 构建，利用事件驱动模型处理高并发连接。这一选择兼顾了开发效率与运行时性能，使得单个 Gateway 进程能够同时管理数十个信道连接和多个智能体会话。

**WebSocket 服务器** 是控制平面的核心通信枢纽。默认配置下，它监听 `127.0.0.1:18789`，提供全双工、低延迟的实时通信通道。WebSocket 协议的选择源于 AI 助手场景的交互特性：流式响应（streaming responses）需要服务器主动推送数据，传统 HTTP 轮询方案在延迟和效率上均无法满足需求。Gateway 的 WebSocket 实现支持文本和二进制帧，承载 JSON-RPC 2.0 消息、流式令牌、控制指令等多种负载类型。

**JSON-RPC 2.0 方法调度系统** 提供了标准化的远程调用接口。Gateway 注册了大量的内置方法，涵盖智能体管理（`agent.create`、`agent.destroy`）、信道操作（`channel.send`、`channel.receive`）、工具调用（`tools.invoke`）等核心功能。方法调度器实现了请求/响应的关联追踪、批量请求处理、以及异步通知机制。

**会话生命周期管理** 是控制平面的另一关键职责。Gateway 维护会话状态机，跟踪每个会话的创建、激活、休眠、恢复、销毁全过程。会话标识采用分层设计：`session.mainKey` 区分主会话（默认 "main"）与非主会话，后者包括群聊、频道、定时任务等场景。这种区分直接影响沙箱策略的应用范围——`non-main` 模式下的沙箱化决策即基于此属性。

**多层认证系统** 保障控制平面的访问安全：

| 层级 | 机制 | 用途 |
|:---|:---|:---|
| API Key | LLM 提供商认证 | 模型调用身份验证 |
| 会话令牌 | Gateway 客户端认证 | CLI、Chat UI、移动应用连接 |
| mTLS（可选） | 双向证书认证 | 生产环境高安全部署 |

##### 1.2.1.2 信道连接管理

Gateway 的信道连接管理功能体现了 OpenClaw 的 **"全平台覆盖"** 野心。截至 2026 年 2 月，官方支持的平台包括：

| 平台类别 | 代表平台 | 技术实现 | 特性支持 |
|:---|:---|:---|:---|
| 个人社交 | WhatsApp | Baileys（WhatsApp Web 协议） | 完整功能，需手机扫码配对 |
| 个人社交 | Telegram | Bot API（grammY） | 草稿流式显示、富媒体、内联键盘 |
| 个人社交 | iMessage | imsg CLI（macOS 专属） | Apple 私有协议，原生体验 |
| 团队协作 | Slack | Bolt SDK | Block Kit UI、工作区集成 |
| 团队协作 | Discord | discord.js | Gateway 意图、Embed 消息、斜杠命令 |
| 团队协作 | Feishu/Lark | 开放平台 API | 中国本土企业市场 |
| 传统通讯 | SMS | Twilio 等网关 | 广泛触达，异步交互 |

这种广泛的信道覆盖使得用户无需改变既有通讯习惯即可使用 AI 助手。每个平台通过独立的 **信道适配器（Channel Adapter）** 接入，适配器负责平台特定协议的处理，将异构消息格式转换为 OpenClaw 内部的标准消息结构。

信道适配器的标准化设计是扩展性的关键。所有适配器遵循统一的接口契约：入站消息转换为内部标准格式，出站消息转换为目标平台格式，平台特定功能通过扩展字段实现。这种设计使得新增平台支持无需修改 Gateway 核心代码，开发者只需实现适配器接口即可。

##### 1.2.1.3 路由与协调机制

**智能体通信协调** 是 Gateway 的高级功能，支撑多智能体场景的复杂交互。Gateway 维护智能体注册表，记录每个智能体的标识、能力、状态、关联会话等信息。当消息到达时，路由引擎根据配置规则（信道、账户、群组、工作区隔离等）确定目标智能体。

路由规则的灵活性是 OpenClaw 适应多样化场景的基础。典型配置包括：按信道路由（WhatsApp 消息由"个人助手"处理，Slack 消息由"工作助手"处理）、按联系人路由（特定客户由"销售专员"智能体服务）、按群组路由（每个项目群组拥有独立的上下文和工具集）。

**Canvas 主机** 是 Gateway 提供的视觉界面管理能力，运行于端口 18793，服务路径 `/__openclaw__/canvas/`。它本质上是一个轻量级 HTTP 文件服务器，为智能体生成的可视化内容（图表、仪表盘、交互界面）提供托管和访问能力。Node WebViews 等客户端组件通过该端点获取渲染资源，实现与对话流集成的富媒体体验。

#### 1.2.2 Agent Core（智能体核心）

##### 1.2.2.1 Pi Agent Core 封装层

Agent Core 的技术实现基于 **Pi Agent Core** 封装层，这是 OpenClaw 与底层 AI 能力之间的抽象边界。Pi（原称 Moltbot/Clawdbot 内部代号）是项目早期开发的核心运行时，经过多轮迭代后成为可复用的智能体框架。封装层的设计目标是解耦 Gateway 的编排逻辑与 Agent Core 的推理实现，允许两者独立演进。

封装层提供的核心抽象包括：**会话上下文管理**（将 Gateway 传递的会话状态转换为 LLM 可用的消息历史）、**工具调用编排**（将 LLM 的工具使用请求转换为可执行操作并返回结果）、**流式响应处理**（管理令牌级流式输出与完整响应的组装）。这些抽象通过 **Pi RPC 协议** 暴露给 Gateway，形成清晰的进程间边界。

##### 1.2.2.2 AI 能力承载与执行引擎

AI 能力的承载通过 **模型无关的设计** 实现，这是 OpenClaw 区别于单一模型绑定产品的关键特性。Model Resolver 组件负责将抽象的能力请求映射到具体的 LLM 调用，同时处理认证、重试、降级等横切关注点。

**多模型故障转移机制** 体现了生产级可靠性设计。OpenClaw 实现了三层独立的故障转移策略：

| 层级 | 机制 | 触发条件 | 回退策略 |
|:---|:---|:---|:---|
| Layer 1 | 认证配置轮转 | API key 速率限制/失效 | 切换备用配置 |
| Layer 2 | 思考级别降级 | 模型不支持高复杂度推理 | 高 → 中 → 低 → 关闭 |
| Layer 3 | 模型级联 | 前述均失败 | Claude Opus → GPT-4o → Gemini 2.0 Flash |

执行引擎的核心是 **ReAct（Reasoning + Acting）循环** 的变体实现。LLM 接收用户输入和系统提示，生成思考过程和工具调用请求，引擎执行工具并将结果反馈给 LLM，循环直至任务完成或达到最大迭代次数。OpenClaw 的优化包括：并行工具执行、工具结果流式返回、执行轨迹的实时可视化。

##### 1.2.2.3 Pi RPC 协议通信接口

Pi RPC 是 Gateway 与 Agent Core 之间的专用通信协议，针对智能体场景优化。关键扩展包括：

- **`stream` 响应类型**：服务器主动推送的无限流，用于 LLM 令牌
- **`blob` 参数类型**：高效传输大二进制数据（图像、文件）
- **`deadline` 元数据**：执行超时提示，支持取消信号传播

传输层默认采用 **stdio 管道**（Gateway 以子进程方式启动 Agent Core），这种设计简化了部署（无需网络配置）并提供了天然的进程隔离。对于高级场景，支持通过 TCP 或 Unix Domain Socket 连接独立运行的 Agent Core 实例。

##### 1.2.2.4 推理与决策模块

推理模块实现了 **多模式推理策略**：

| 模式 | 特点 | 适用场景 |
|:---|:---|:---|
| 快速模式（Fast） | 单轮推理，最低延迟 | 简单查询、翻译 |
| 标准模式（Standard） | 多轮 ReAct 循环，平衡能力效率 | 一般任务处理 |
| 深度思考模式（Deep） | 扩展推理链，自我批评优化 | 复杂分析、创造性任务 |

决策模块集成了 **安全护栏机制**。在每次工具调用前，系统评估操作的安全风险等级，对于高风险操作（文件删除、网络请求、代码执行）触发用户确认流程或自动拒绝。

#### 1.2.3 Channels（信道层）

##### 1.2.3.1 即时通讯信道矩阵

Channels 层构成了 OpenClaw 与用户交互的多元入口。官方支持的 12+ 平台可分为三类：**个人社交类**（WhatsApp、iMessage、Telegram DM）、**团队协作类**（Slack、Discord、Telegram Groups、Feishu/Lark）、**传统通讯类**（SMS，通过 Twilio 等网关）。

各平台的技术集成深度存在差异。最深度的集成以 **Telegram** 为代表：支持草稿流式显示（实时更新输入框内容模拟"正在输入"）、富媒体消息、交互元素（内联键盘、回调按钮）、甚至支付功能。**WhatsApp** 集成受限于官方 API 的封闭性，主要通过 WhatsApp Web 协议实现，功能集相对有限但覆盖最广。

##### 1.2.3.2 自定义输入流接口

除即时通讯平台外，OpenClaw 支持多种自定义输入源：**Webhook 接口**（外部系统通过 HTTP POST 触发）、**文件系统监视**（特定目录变化转化为事件流）、**定时任务（cron）**（按 schedule 激活智能体，实现"Heartbeat"主动行为）。

这些输入源统一抽象为 **Trigger（触发器）** 概念，与信道消息共享相同的后续处理流程。触发器携带的元数据（来源类型、时间戳、关联资源）影响路由决策和上下文组装。

##### 1.2.3.3 双向消息传输机制

消息传输的双向性体现在两个维度：Gateway 与平台服务器之间（维持持久连接接收推送，同时主动发送消息），以及 Gateway 与 Agent Core 之间（请求-响应与服务器推送并存）。

**出站消息的优化策略** 因平台而异。Telegram 支持 Markdown 和 HTML 格式化，Gateway 自动转换内部表示；WhatsApp 格式支持有限，执行优雅降级；长消息自动分片，在段落边界处分割保持语义连贯性。

#### 1.2.4 辅助组件

##### 1.2.4.1 CLI 命令行界面

OpenClaw CLI 是面向技术用户的核心交互界面，核心命令包括：

| 命令 | 功能 |
|:---|:---|
| `openclaw onboard --install-daemon` | 引导式初始化配置，一键部署 |
| `openclaw gateway` | Gateway 进程管理（启动/停止/状态） |
| `openclaw doctor` | 全面健康检查，识别安全风险 |
| `openclaw skill` | 技能包管理（搜索/安装/更新/卸载） |
| `openclaw cron add "<cron>" "<command>"` | 定时任务配置 |

CLI 的设计遵循 Unix 哲学：命令组合、管道友好、配置即代码。所有配置存储于 JSON 文件，可通过版本控制管理。

##### 1.2.4.2 Chat UI 交互界面

Chat UI 是 OpenClaw 的原生图形界面，采用 **SwiftUI（macOS/iOS）** 和 **Kotlin/Jetpack Compose（Android）** 构建。与第三方平台集成相比，原生 UI 支持更丰富的交互模式：语音消息、相机直接调用、地理位置共享、系统级通知。

界面架构采用 MVVM 模式，ViewModel 层通过 Gateway WebSocket 客户端与后端同步状态。离线支持通过本地数据库（Core Data/Room）实现，网络恢复后自动同步。

##### 1.2.4.3 控制仪表盘（Dashboard）

控制仪表盘是 Gateway 内置的 Web 管理界面，提供：实时会话列表、系统指标（内存使用、请求速率、错误率）、配置编辑器（带语法验证和即时生效）、日志查看器（流式 tail，支持搜索和过滤）。

仪表盘的安全模型与 Gateway 控制平面一致：**默认仅本地访问**，远程访问需通过隧道或显式绑定配置。2026 年 1 月的安全事件暴露了早期版本的认证绕过漏洞，后续版本强化了令牌验证和 CSRF 防护。

### 1.3 数据流与交互机制

#### 1.3.1 消息流转路径

##### 1.3.1.1 入站流程：信道 → Gateway → Agent Core

入站消息的处理是高度并发的流水线：

| 阶段 | 处理内容 | 技术要点 |
|:---|:---|:---|
| 信道接收 | 平台适配器接收原始消息，协议解析 | Baileys、grammY、discord.js 等库 |
| 标准化转换 | 转换为内部 `Message` 结构 | 统一字段：id、source、content、context |
| 预处理过滤 | 垃圾信息检测、命令解析、媒体提取 | 异步并行，规则预编译 |
| Gateway 路由 | 规则匹配确定目标智能体 | 信道/联系人/群组多维度 |
| Agent Core 处理 | ReAct 循环，工具调用，响应生成 | 流式输出，上下文管理 |

##### 1.3.1.2 出站流程：Agent Core → Gateway → 信道

出站流程的复杂性源于 **多平台格式适配**：

1. **内容分析**：Agent Core 输出结构解析（文本/代码/图片/Canvas 链接）
2. **平台适配**：内部富文本格式转换为目标平台原生格式
3. **富媒体处理**：图片/文件上传至平台 CDN 获取可发送 URL
4. **交互元素生成**：按钮、菜单等转换为平台特定 API 调用
5. **Gateway 投递**：调用信道适配器发送接口
6. **确认与重试**：监控状态，失败重试，错误上报

##### 1.3.1.3 内部事件总线机制

Gateway 内部采用 **事件驱动架构** 解耦组件。核心事件类型包括：`MessageReceived`（新消息到达）、`AgentResponse`（智能体响应就绪）、`ToolExecuted`（工具执行完成）、`SessionStateChanged`（会话状态迁移）、`ChannelStatusChanged`（信道连接状态变化）。

事件总线的实现基于 Node.js 的 EventEmitter，支持同步和异步处理器。关键路径使用同步处理保证时序，后台任务使用异步处理避免阻塞。

#### 1.3.2 组件间通信协议

##### 1.3.2.1 WebSocket 实时双向通道

WebSocket 是 Gateway 与外部客户端的主要通信协议。协议扩展包括：心跳机制（30 秒间隔检测死连接）、二进制帧支持（高效传输音频/图像）、压缩协商（permessage-deflate 减少文本负载）。

##### 1.3.2.2 JSON-RPC 2.0 远程调用

JSON-RPC 2.0 是 Gateway 对外暴露的结构化 API 协议。方法命名空间按功能组织：`gateway.*`（Gateway 管理）、`agent.*`（智能体控制）、`channel.*`（信道操作）、`tool.*`（工具执行）、`session.*`（会话管理）。

##### 1.3.2.3 Pi RPC 智能体专用协议

Pi RPC 在 JSON-RPC 2.0 基础上扩展了智能体特定语义，传输层默认采用 **stdio 管道** 简化部署，高级场景支持 TCP 或 Unix Domain Socket。

#### 1.3.3 会话模型

##### 1.3.3.1 会话状态机管理

会话状态机定义了生命周期各阶段：

| 状态 | 说明 | 触发转换 |
|:---|:---|:---|
| `CREATED` | 初始化，等待首次交互 | 用户消息到达 → `ACTIVE` |
| `ACTIVE` | 正常处理消息 | 超时/用户暂停 → `PAUSED` |
| `PAUSED` | 显式暂停或超时无活动 | 用户消息到达 → `RESUMING` |
| `RESUMING` | 从持久化状态恢复 | 恢复完成 → `ACTIVE` |
| `CLOSING` | 清理中 | 完成 → `CLOSED` |
| `CLOSED` | 已销毁，资源释放 | — |

##### 1.3.3.2 上下文保持与恢复

上下文保持通过 **分层存储** 实现：

| 层级 | 存储位置 | 内容 | 恢复策略 |
|:---|:---|:---|:---|
| 热上下文 | 内存 | 最近 N 轮对话 | 直接用于 LLM 输入 |
| 温上下文 | 工作区文件 | 近期历史、会话元数据 | 快速加载，滑动窗口 |
| 冷上下文 | 压缩摘要、向量索引 | 关键提取、长期记忆 | 按需检索，语义召回 |

##### 1.3.3.3 多轮对话连续性保障

多轮连续性依赖 **精确的引用追踪**。用户消息可显式引用之前消息（通过回复功能），隐式引用通过会话历史维护。Agent Core 的推理将引用关系纳入上下文，理解"这个"、"上次说的"等指代表达。跨会话连续性通过长期记忆文件（`MEMORY.md`、每日笔记）和向量检索实现。

## 2. 关键技术实现

### 2.1 工作区隔离（Workspace Isolation）

#### 2.1.1 工作区抽象模型

##### 2.1.1.1 工作区作为智能体运行环境

OpenClaw 的 **工作区（Workspace）** 是智能体的核心运行环境抽象。默认工作区位于 `~/.openclaw/workspace/`（或带 profile 后缀的变体），这一位置可通过配置覆盖。工作区的内容组织遵循约定优于配置原则：

| 路径 | 用途 | 持久化策略 |
|:---|:---|:---|
| `MEMORY.md` | 长期个人记忆，主会话加载 | 关键更新时同步刷新 |
| `notes/` | 按日期组织的每日笔记 | 自动压缩和归档 |
| `skills/` | 自定义技能开发目录 | Git 版本控制推荐 |
| `scripts/` | 用户脚本和自动化 | 手动管理 |
| `data/` | 应用数据（下载文件、数据库） | 定期清理 |

这种文件化的工作区设计带来了独特优势：用户可直接使用熟悉的文件管理工具浏览和编辑；可使用 Git 进行版本控制；可使用 Obsidian、Notion 等知识管理工具打开记忆目录。

##### 2.1.1.2 文件工具专属工作目录

文件工具（`read`、`write`、`edit`、`apply_patch` 等）的操作范围默认限制于工作区。工具实现将相对路径解析为工作区内的绝对路径，拒绝解析到工作区外的路径（除非显式配置 `workspaceAccess: "rw"` 且未启用沙箱）。

**工作区访问权限的三级模型**：

| 模式 | 说明 | 适用场景 |
|:---|:---|:---|
| `"none"` | 完全隔离，智能体看不到任何主机文件 | 完全不可信输入 |
| `"ro"` | 只读访问工作区内容 | 平衡安全与功能（推荐）|
| `"rw"` | 完整读写 | 高度信任场景 |

##### 2.1.1.3 工作区上下文隔离边界

上下文隔离确保不同工作区的智能体互不干扰。**内存层面**，每个 Agent Core 实例加载独立的工作区文件；**进程层面**，可选的每工作区进程隔离防止资源泄漏；**网络层面**，沙箱化的工作区拥有独立的网络命名空间。

#### 2.1.2 隔离层级设计

| 层级 | 机制 | 隔离强度 | 性能开销 |
|:---|:---|:---|:---|
| 进程级隔离 | 独立操作系统进程 | 地址空间分离 | 低 |
| 文件系统命名空间隔离 | Linux mount namespace + bind mounts | 文件系统视图隔离 | 中 |
| 网络命名空间隔离 | Linux network namespace | 网络栈完全独立 | 中 |

#### 2.1.3 工作区生命周期

- **动态创建与销毁**：`openclaw onboard` 引导初始化，`skipBootstrap: true` 禁用自动引导文件创建
- **状态持久化与恢复**：对话历史增量写入，记忆文件关键更新时同步，配置变更即时保存
- **资源配额管理**：磁盘配额、内存限制、CPU 时间、网络带宽可配置

### 2.2 沙箱执行（Sandbox Execution）

#### 2.2.1 容器化执行引擎

OpenClaw 的沙箱执行基于 **Docker 容器运行时**，利用成熟的隔离机制和生态系统。核心组件包括：

| 组件 | 职责 |
|:---|:---|
| 镜像管理 | 基础镜像构建、缓存、分发 |
| 容器生命周期 | 创建、监控、回收 |
| 资源限制 | CPU/内存/IO 配额强制执行 |

镜像构建通过 `scripts/sandbox-setup.sh` 完成，基于官方 Node.js 镜像添加 OpenClaw 工具依赖。

#### 2.2.2 沙箱模式配置

| 模式 | 配置值 | 说明 | 适用场景 |
|:---|:---|:---|:---|
| `off` | `"off"` | 无沙箱，主机直接执行 | 本地开发、完全可信环境 |
| `non-main` | `"non-main"` | 仅非主会话沙箱化 | 多智能体场景（推荐）|
| `all` | `"all"` | 所有会话沙箱化 | 生产环境、不可信输入 |

**`non-main` 模式** 是平衡安全与便利的推荐配置：主会话（用户与 AI 的直接私聊）在主机执行，保持完整功能和最低延迟；其他会话（群聊、频道、定时任务）自动沙箱化。

#### 2.2.3 安全边界强化

| 机制 | 实现 | 作用 |
|:---|:---|:---|
| 系统调用过滤 | Seccomp 配置文件 | 阻断危险调用（`mount`、`pivot_root` 等）|
| capabilities 降权 | `--cap-drop=all` + 显式 `cap-add` | 最小权限原则 |
| AppArmor/SELinux | 强制访问控制策略 | 文件/网络/IPC 访问限制 |

#### 2.2.4 工具执行隔离

- **工具沙箱化运行**：高风险工具（`bash`、`python`、`browser`）默认沙箱化
- **影响范围最小化**：`scope: "session"`（每会话独立）、`"agent"`（每智能体共享）、`"shared"`（所有沙箱共享）
- **执行超时与熔断**：`timeoutMs` 配置强制终止，连续失败触发工具暂停

### 2.3 多智能体协作（Multi-Agent Collaboration）

#### 2.3.1 智能体编排模型

**主从架构（Principal-Specialist Pattern）** 是典型模式：主智能体协调多个专精智能体，各自负责特定领域（研究、日程、监控等）。技术实现上，每个智能体是独立的 Agent Core 实例，Gateway 的路由规则将特定输入导向特定智能体，智能体间通过消息传递通信。

#### 2.3.2 协作通信机制

- **智能体间消息传递**：扩展标准消息格式，添加 `recipient_agent_id`、`correlation_id`、`priority`、`deadline`
- **共享状态与上下文同步**：显式状态传递，避免隐式共享内存
- **任务委托与结果回调**：主智能体委托子任务，专精智能体异步执行并回调

#### 2.3.3 并发与同步控制

| 机制 | 适用场景 | 实现方式 |
|:---|:---|:---|
| 乐观并发控制 | 读多写少、冲突可自动合并 | 时间戳排序、版本向量 |
| 分布式锁 | 冲突高发、需强一致性 | 文件系统 `flock`、Redis、etcd |
| 冲突检测与解决 | 结构化数据、语义冲突 | LLM 辅助智能合并 |

#### 2.3.4 协作安全边界

- **智能体身份认证**：证书或共享密钥，Gateway 验证签名链
- **权限最小化原则**：每智能体显式配置可调用的工具子集、可访问的工作区范围
- **跨智能体访问审计**：所有通信记录审计日志，用于安全分析、合规报告、故障排查

### 2.4 统一消息协议（Unified Messaging Protocol）

#### 2.4.1 协议分层设计

| 层级 | 协议/格式 | 职责 |
|:---|:---|:---|
| 传输层 | WebSocket/TCP | 可靠字节流，全双工通信 |
| 帧层 | WebSocket 帧 | 消息边界、掩码、心跳 |
| 表示层 | JSON（MessagePack 可选）| 结构化数据序列化 |
| 应用层 | JSON-RPC 2.0 / Pi RPC | 远程调用语义、智能体扩展 |

#### 2.4.2 消息格式标准化

**请求消息结构**：
```json
{
  "type": "req",
  "id": "uuid-v4",
  "method": "agent.invoke",
  "params": { "prompt": "...", "tools": ["read", "exec"] }
}
```

**响应消息结构**：
```json
{
  "type": "res",
  "id": "uuid-v4",
  "ok": true,
  "payload": { ... }
  // 或 "error": { "code": "...", "message": "..." }
}
```

**事件消息结构**：
```json
{
  "type": "event",
  "event": "agent.stream",
  "payload": { "runId": "...", "delta": "..." },
  "seq": 42,
  "stateVersion": 7
}
```

#### 2.4.3 协议扩展机制

- **方法注册与动态发现**：运行时注册新方法，`methods.list` 查询可用接口
- **版本协商与兼容性**：连接建立时交换协议版本，不匹配触发降级或错误
- **自定义扩展字段**：`meta` 字段承载追踪 ID、超时提示、优先级等

#### 2.4.4 信道适配协议

| 适配维度 | 处理内容 | 示例 |
|:---|:---|:---|
| 平台特定格式转换 | Markdown 方言、HTML、纯文本 | Telegram HTML → WhatsApp 纯文本降级 |
| 富媒体消息处理 | 图片、视频、文件、位置 | 上传 CDN、生成缩略图、格式转码 |
| 交互元素映射 | 按钮、卡片、菜单、表单 | 内联键盘、Block Kit、Embed 消息 |

### 2.5 记忆管理机制

#### 2.5.1 会话记忆（Session Memory）

| 技术 | 说明 |
|:---|:---|
| 短期上下文窗口 | 最近 N 轮对话，直接用于 LLM 输入 |
| 对话历史压缩 | 智能摘要提取，保留关键转折点 |
| 关键信息提取 | 实体识别、意图标记、承诺追踪 |

#### 2.5.2 长期记忆（Long-term Memory）

| 组件 | 技术实现 | 用途 |
|:---|:---|:---|
| 向量数据库存储 | SQLite-vec / 可选外部向量库 | 语义嵌入存储 |
| 语义检索与召回 | 余弦相似度、近似最近邻 | 相关记忆动态加载 |
| 记忆衰减与更新 | 时间衰减因子、显式用户反馈 | 旧记忆淡化、错误记忆修正 |

### 2.6 插件系统（Plugin System）

#### 2.6.1 Plugin SDK 架构

OpenClaw 的插件系统基于 **Skill SDK**，技能定义为包含 `SKILL.md` 配置文件的目录，通过 YAML frontmatter 声明元数据、依赖、入口点。ClawdHub 提供 **700+ 社区技能**，涵盖 API 集成、数据处理、自动化工作流等类别。

#### 2.6.2 插件加载机制

- **动态加载与热更新**：运行时安装、更新、启用/禁用技能
- **依赖解析与版本管理**：自动安装 npm 依赖，处理版本冲突
- **沙箱化插件执行**：高风险技能在容器内运行，与核心系统隔离

## 3. 架构优势与特点

### 3.1 本地优先（Local-First）

#### 3.1.1 数据主权保障

OpenClaw 的本地优先架构实现了 **完整的数据主权**：

| 维度 | 传统 SaaS AI 助手 | OpenClaw 本地优先 |
|:---|:---|:---|
| 数据存储位置 | 服务商云端服务器 | 用户本地设备 |
| 数据访问控制 | 服务商条款约束 | 用户完全控制 |
| 服务可用性依赖 | 网络连接 + 服务商运营 | 本地运行，可选网络 |
| 数据可携带性 | 导出受限或付费 | 标准文件格式，自由迁移 |
| 合规审计 | 依赖服务商认证 | 完全透明，自主审计 |

#### 3.1.2 隐私保护设计

- **敏感信息不出境**：默认本地存储，模型 API 调用仅传输必要提示文本
- **本地模型推理支持**：Ollama、LM Studio 等集成，实现零云端传输
- **审计日志本地留存**：结构化日志本地存储，可选导出到 SIEM

#### 3.1.3 离线可用性

| 功能 | 离线支持 | 说明 |
|:---|:---|:---|
| 核心对话 | ✓ | 本地模型或缓存响应 |
| 文件操作 | ✓ | 直接工作区访问 |
| 脚本执行 | ✓ | 本地运行时环境 |
| 网络工具 | ✗ | 需连接恢复 |
| 云端模型 | ✗ | 需网络连接 |

网络恢复后，异步同步机制自动处理队列中的 outbound 消息和状态更新。

### 3.2 生产级运行时平台

#### 3.2.1 高可用性保障

| 机制 | 实现 | 效果 |
|:---|:---|:---|
| 进程监控 | launchd（macOS）/ systemd（Linux）自动重启 | 崩溃后秒级恢复 |
| 状态持久化 | 可选 SQLite/文件系统会话存储 | 重启后上下文恢复 |
| 健康检查 | `health` 方法 + Dashboard 状态页 | 主动故障发现 |

#### 3.2.2 性能优化

- **事件驱动异步架构**：Node.js 事件循环，单线程高并发
- **连接池与资源复用**：IM 平台长连接保持，HTTP 客户端连接池
- **流式响应支持**：SSE/WebSocket 流式传输，首 token 延迟显著降低

#### 3.2.3 可观测性

| 维度 | 机制 | 输出 |
|:---|:---|:---|
| 日志 | 结构化 JSON，可配置级别 | stdout / 文件 / 外部收集 |
| 指标 | Prometheus 格式端点 | Gateway 性能、Agent 执行统计 |
| 追踪 | OpenTelemetry 集成 | 请求全链路追踪 |

### 3.3 高安全性（High Security）

#### 3.3.1 网络安全模型

| 策略 | 实现 | 目的 |
|:---|:---|:---|
| Loopback-First | 默认 `127.0.0.1:18789` | 最小攻击面 |
| 默认拒绝入站 | 无显式配置拒绝远程连接 | 防止未授权访问 |
| TLS/mTLS 加密 | 反向代理或内置 TLS | 传输层安全 |

#### 3.3.2 认证与授权

- **多层认证体系**：API Key + 会话令牌 + 可选 mTLS
- **基于角色的访问控制（RBAC）**：`operator`、`node`、`adapter` 三类角色，点符号权限树
- **最小权限原则执行**：每智能体、每工具、每会话的精细权限配置

#### 3.3.3 代码安全

- 依赖漏洞扫描（`npm audit` 集成）
- 静态代码分析（ESLint、TypeScript 严格模式）
- 密钥泄露检测（detect-secrets）

#### 3.3.4 运行时安全

| 机制 | 实现 | 防护目标 |
|:---|:---|:---|
| 沙箱逃逸防护 | Seccomp、capabilities、MAC 多层隔离 | 容器突破 |
| 资源耗尽防护 | cgroup 配额、超时熔断 | DoS 攻击 |
| 异常行为监控 | 规则引擎检测异常模式 | 内部威胁 |

### 3.4 可扩展性（Extensibility）

#### 3.4.1 水平扩展能力

| 场景 | 方案 | 说明 |
|:---|:---|:---|
| 网关集群部署 | 多 Gateway + 负载均衡 | 状态外部化至 Redis |
| 智能体负载均衡 | 智能体池 + 任务队列 | 基于能力标签的路由 |
| 状态外部化存储 | Redis / PostgreSQL | 会话共享，故障转移 |

#### 3.4.2 垂直扩展能力

- **模块化组件替换**：模型提供商、信道适配器、记忆存储均可插拔
- **自定义信道接入**：Adapter SDK，社区已贡献 Feishu/Lark、钉钉等
- **私有模型集成**：OpenAI-compatible API 适配，本地模型 Ollama 集成

#### 3.4.3 生态扩展

- **开放插件市场**：ClawdHub 700+ 技能
- **社区贡献机制**：开源 MIT 协议，活跃 Discord 社区
- **企业定制支持**：官方托管服务、SLA 保障、专属支持

### 3.5 跨平台兼容性

#### 3.5.1 操作系统覆盖

| 平台 | 支持级别 | 特性 |
|:---|:---|:---|
| macOS 14+ | 一级支持 | SwiftUI 原生应用，语音唤醒，iMessage |
| Linux（Ubuntu/Debian）| 一级支持 | systemd 集成，VPS 部署理想 |
| Windows（WSL2）| 二级支持 | 功能完整，需 WSL2 层 |
| iOS/Android | 节点模式 | 配套应用，远程感官/执行器 |

#### 3.5.2 部署形态多样

| 形态 | 技术栈 | 适用场景 |
|:---|:---|:---|
| 桌面应用 | Electron/Tauri（实验性）| 个人用户一键安装 |
| 服务器容器 | Docker / Docker Compose / Kubernetes | 企业部署、规模化运维 |
| 边缘设备 | 树莓派 4/5、Mac Mini | 轻量部署，< 1GB RAM（不含本地模型）|

## 4. 典型应用场景与架构映射

### 4.1 个人 AI 助手部署

#### 4.1.1 单用户本地模式

最简部署：单台 MacBook/Linux 笔记本，Gateway 本地运行，通过 Telegram/WhatsApp 交互，模型使用 Claude API 或本地 Ollama。零基础设施成本，完全隐私保护，功能覆盖个人生产力（日历、任务、文件管理、代码辅助）。

#### 4.1.2 多设备同步架构

iPhone/Android 配套作为 Gateway 的"节点"，提供相机、GPS、麦克风等移动能力，执行结果同步回主设备。配对流程通过二维码或短码完成，建立端到端加密的安全通道。

### 4.2 企业级智能体平台

#### 4.2.1 多租户隔离方案

通过 **工作区隔离 + 沙箱配置** 实现逻辑多租户：每个团队/项目独立工作区，Agent 实例隔离，共享 Gateway 基础设施。进阶部署采用多 Gateway 实例 + 负载均衡，实现物理隔离。

#### 4.2.2 集中管控与审计

- 集中身份源（LDAP/SSO）集成
- 操作日志集中收集（SIEM 集成）
- 预批准技能白名单
- 网络出口代理和 DLP 检查

### 4.3 自动化工作流引擎

#### 4.3.1 定时任务调度（Cron Agent）

`openclaw cron add "<cron>" "<command>"` 配置定时任务。Cron Agent 作为特殊 Agent 实例，在指定时间唤醒，执行预设工作流，结果通过配置的信道通知用户。典型用例：每日 8 AM 早间简报（日历摘要、邮件优先级排序、待办提醒）。

#### 4.3.2 事件驱动响应链

通过 Webhook、Gmail Pub/Sub、文件系统监视等触发器，构建事件驱动的自动化链。例如：GitHub 新 Issue → 自动分类 → 创建 Notion 页面 → Slack 通知 → 分配给值班工程师。
